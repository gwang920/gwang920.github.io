---
title: Array vs ArrayList vs LinkedList
categories:	
    - DataStructure
tags:
- 자료구조
- Array
- ArrayList
- LinkedList
last_modified_at:
---





자료구조를 공부할 때, **Array와 ArrayList**의 혹은 **ArrayList 와 LinkedList**의 차이점을 비교하는 글이 많았다. 그런데 항상 위 3개 자료구조의 쓰임새가 명확하게 와닿지 않았고, 때로는 헷갈리기도 했다. 그래서 한 번에 비교하며, 정리해보려 한다.



## 1) Array

Array는 우리가 흔히 알고 있는 배열이라 할 수 있다. 가장 기본적인 자료구조이며, 순차자료구조라고 할 수 있다. **논리적인 저장순서**와 **물리적인 저장순서**가 **일치**한다는 특징을 가지고 있다. 따라서, 인덱스로 해당 원소에 접근 할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있다면 **Big-O(1)**에(참조시간이 상수) 해당 원소로 접근할 수 있다. 즉 **Random Access**가 가능하다.

하지만, **삽입** 또는 **삭제** 과정에서는 해당원소에 접근하여 작업을 완료한 뒤(Big-O(1)) 또 한가지의 작업을 추가적으로 해줘야한다. 만약 배열의 어떤 요소에 삽입 또는 삭제를 했다면 배열의 연속적인 특징이 깨진다. 따라서 삽입 또는 삭제한 원소보다 크 인덱스를 갖는 원소들을 shift해줘야하는 비용이 발생하고, 이 경우 시간복잡도는(O(n))이 된다. 따라서 Array 자료구조의 시간복잡도의 **worst case**는 **O(n)**이 된다.

처음에는 **정적인 자료구조**인 Array에 데이터를 삽입하고, 삭제한다는 개념이 와닿지 않았다. 실제로 코딩을 해보면 데이터의 삽입, 삭제가 이루어지는 Vector나 Queue와는 다르지않나? 라는 생각이 들기도 했다. 사실, Array에서 삽입 삭제는 데이터의 교환이라고 할 수 있다. 인덱스를 유지하면서(정적) 값을 추가하고, 삭제해야하기 때문이다. 

## 요약

1) Array는 논리적인 저장순서와 물리적인 저장순서가 일치한다.

2) 데이터에 접근하는 서치 시간복잡도는 O(1)이다.

3) 삽입,삭제는 데이터의 교환과도 같다. 시간복잡도는 shift 비용으로 worst case는 O(N)이 된다.



## 2) ArrayList





# Reference

-  https://zorba91.tistory.com/287
- http://www.nextree.co.kr/p6506/

